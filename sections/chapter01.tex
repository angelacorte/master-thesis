%! Author = angela
%! Date = 24/01/24
% !TeX root = ../thesis-main.tex

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{ch:introduction}
%----------------------------------------------------------------------------------------
This chapter introduces the background of this thesis, including our position, main objectives,
and the current state of the art.

\section{Context}
\label{sec:context}

Computing devices are becoming cheaper and more \emph{ubiquitous}, increasing the complexity of distributed systems.
It is now common for individuals to own multiple computing devices of varying types,
resulting in technology becoming more integrated into daily activities.
Hence, the need to engineer and coordinate the operations in such systems, one way is to program and operate in terms of
    \emph{aggregates} devices, rather than manage each single device.
In fact, the coordination of macroscopic behaviour in collective systems through a single program is a form of
~\emph{macroprogramming}.
However, this approach presents some primary challenges such as ensuring resilience, efficiency and privacy.

\paragraph{Macroprogramming}
%todo cite Macroprogramming: Concepts, State of the Art, and Opportunities of Macroscopic Behaviour Modelling
The term \emph{macroprogramming} refers to the concept of expressing the macroscopic behaviour of a system through a single
program, usually leveraging macro-level abstractions.
This paradigm is driven by the need to capture \emph{system-level behaviour} while abstracting the behaviour and interaction
of the individual components involved.
Macroprogramming approaches have been suggested to simplify the development of systems involving numerous interconnected
sensors, actuators, and smart devices; they can be applied in contexts like \ac{iot} and \ac{cps}.

By declaring tasks within a specific spatio-temporal region, systems can self-organise and effectively perform the task
at hand, allowing for dynamic adaptation to the current deployment and spatial positions of the components involved.

Macroprogramming abstractions can promote collective behaviour properties, such as self-organising or self-configuring in
the context of \ac{cas}.

\paragraph{Self-Organisation}
Coordination modes are based on the notion that interactions among multiple independent and autonomous software systems
can be designed as a space orthogonal to pure computation.
This idea can be reified into a concept of shared data space, enabling so-called \emph{generative communication}.
%Todo talk about Linda and Mars ???

Over the course of time, different approaches have been created, such as \emph{Linda} and \emph{Mars},
suggesting innovative techniques for programming systems with devices of different nature focusing on the coordination
of centralised local components, but not on the distribution of the systems.
The main problems that can be encountered in distributed systems are dealing with
    i) openness, as unexpected environment changes,
    ii) large scale of agents and coordination abstractions to be managed,
    iii) intrinsic adaptiveness, such as the ability to intercept relevant events and react to them, guaranteeing
        the resilience of the system.

The challenges necessitate a \emph{self-organising coordination} approach, wherein coordination abstractions solely
manage logical interactions.
This ensures the emergence of global and robust patterns of correct coordination behaviour.


\subsection{Computational Fields}
\label{subsec:computational-fields}
%todo cite From distributed coordination to field calculus and aggregate computing

\paragraph{Field-Based Coordination}
To facilitate self-organisation patterns of agents in complex environments, the concept of \emph{coordination field}
has been introduced.
This abstraction serves as a navigational tool for agents over the actual environment.
%todo cite tota

In this context, the tuple-based middleware TOTA (Tuples On The Air) has been suggested to support field-based
coordination for pervasive-computing applications.
Initially, each field of the tuple in the system was assigned a name, along with a formula that supports the
if-then-else construct and includes arithmetic and boolean operators to specify the field's behaviour over time.
Secondly, it was introduced an operator in the tuple space responsible for applying formulas using contextual information.\\

Somewhat independently of the challenge of identifying appropriate coordination models for distributed and situated systems,
several studies have tackled analogous issues in the broader endeavour of constructing distributed intelligent systems.
This involves promoting higher abstractions of spatial collective adaptive systems.

\paragraph{Field Calculus}
Among the studies such as for managing space-time computing models for the manipulation of distributed data structures,
the notion of \emph{computational fields} were proposed.
Consequently, the ~\ac{fc} has been proposed as a foundational model for the coordination of computational
devices spread in physical environments, also known as \emph{aggregate computing}.
%todo is it necessary to insert the abstract syntax of the field calculus?
~\ac{fc} was introduced as minimal core calculus with the aim of capturing the fundaments that make use of computational
fields: functions over and with fields, their evolution over time and the construction of field of values from neighbours.

The main concept of \ac{fc} is to specify the aggregate system behaviour of a network of devices, where devices that can
directly communicate with each other are indicated through a dynamic network relation.
An example of its application is within a sensor network with a range of a broadcast communication.

The behaviour is applied through a functional composition of operators that manipulate the computational fields,
called specification, that can be interpreted locally or globally.
A local specification can describe a computation on an individual device executed in asynchronous ``computation rounds'',
including sending or receiving messages from neighbours, getting information from sensors and computing the local value of the field.
In the global view, a field calculus expression specifies a mapping associating each computation round of each device to
the value that it assumes at that space-time event.

This dual nature inherently facilitates the alignment of individual device behaviour with the overarching global behaviour
of the entire network of devices.

%rep(e_1)\{(x)=>e_2\}
%if(e_0)\{e_1\}\{e_2\}
\paragraph{Syntax of field calculus}
The \emph{field calculus} is based on a minimal set of operators.
\begin{itemize}
    \item \emph{Stateful field evolution}: the expression \lstinline|rep(e_1){(x)=>e_2}| describes a field evolving in time.
        \lstinline{e_1} represents the initial field value, the function \lstinline|(x) => e_2| declares how the field changes
        at each execution;
    \item \emph{Neighbour interaction}: the expression \lstinline|nbr{e}| builds a neighbouring field, a view of the field
        values in the surroundings of each device where neighbours are mapped to their evaluations of \texttt{e};
    \item \emph{Domain partitioning}: the expression \lstinline|if(e_0){e_1}{e_2}| splits the computational field into
        two non-communicating zones hosting isolated computations: \lstinline|e_1| where \lstinline|e_0| is \texttt{true} and
        \lstinline{e_2} where \lstinline{e_0} is \texttt{false} %todo fix pedix
\end{itemize}

\subsection{Aggregate Computing}
\label{subsec:aggregate-computing}
%TODO cite Modelling and simulation of Opportunistic IoT Services with Aggregate Computing

\paragraph{Aggregate programming}
Aggregate programming elaborates a layered architecture that aims to simplify the design, creation and maintenance of
distributed systems.

Through this methodology, the fundamental unit of computation shifts from an individual device to a collaborative
ensemble of devices.
It elaborates a layered architecture that aims to simplify the design, creation and maintenance of complex distributed
systems.

Moreover, aggregate programming provides mechanisms for robust and adaptive coordination through simple programming APIs
that implicitly guarantee safety and resilience.
This framework is useful in large-scale scenarios, where there is insufficient fixed network infrastructure, as seen in
situations like crowd management during large public events.

In various environments, interactions between wearable devices such as smartphones can support different kinds of services,
including crowd detection, crowd-aware navigation or dispersal advice.

\paragraph{Aggregate computing}
~\ac{ac} is a paradigm and engineering approach for the compositional development of self-adaptive ~\ac{iot} services
from a global perspective.

It has been developed with the core idea of functionality composing collective behaviours to achieve effective and resilient
complex behaviours in dynamic networks.
It views a given environment as a whole programmable entity whose parts collaboratively produce and consume services
across space and time.
~\ac{ac} is based on the principles of~\ac{fc} that is a functional programming model used to specify
and compose collective behaviours with formally equivalent local and aggregate semantics.

The concept of \emph{computational fields} can be viewed as a distributed data structure,
with the aim of conceptually mapping each device to a value produced in a program, considering both
space and time.
Therefore, its structure supports the specification, analysis, simulation and runtime execution of \emph{collective}
or \emph{aggregate} services, independently of the specific~\ac{iot} architecture.

This paradigm has three key traits that characterise it:
    i) \emph{Global stance with global-to-local mapping}, where the target of system design is the entire distributed
        \ac{iot} ecosystem,
    ii) \emph{Behaviour compositionality}, whereby a rich collective service can be described in terms of the functional
        composition of simpler collective services, and
    iii) \emph{Abstraction}, by which aggregate services enable adaptivity at different levels by abstracting from low-level
        issues and details.
These attributes are crucial both in the design phase, where intricate solutions can frequently be articulated concisely
and declaratively, and in the operational phase, where considerable flexibility is granted to the devops team and the
platform regarding execution specifics and deployment strategies.


\begin{figure}
    \centering
    \includegraphics[width=.5\linewidth]{figures/AC-layers}
    \caption{Aggregate programming abstraction layers}
    \label{fig:ac-layers}
\end{figure}
%todo cite figure

\paragraph{Software platforms}
~\ac{ac} is designed to address many application scenarios, typically characterised by inherent distribution, heterogeneity,
mobility and a lack of stable infrastructure.
There are various strategies by which an~\ac{ac} system can run, contingent upon the selected and implemented
communication methodologies.

Programs can be executed within a fully distributed peer-to-peer environment, where end devices communicate directly
with peer neighbours, and each independently runs its fragment of aggregate logic.

On the opposite side, there are entirely centralised solutions, where end devices function solely as manager for sensors
and actuators, forwarding perceptions upstream to one or more servers.
These servers perform computations on behalf of the devices and subsequently transmit actuation data downstream.
Thanks to this flexibility of its applications,~\ac{ac} has the potential to facilitate the creation of a more systematic
spectrum for transitioning between cloud and distributed systems.
This approach also embraces the emerging domains of edge and fog computing.
%todo talk about edge e fog computing??

\paragraph{Aggregate computing in adaptive \ac{iot} Services}
Thanks to its features, \emph{aggregate computing} is well suited for the development of \emph{Opportunistic \ac{iot}
Services}, supporting the properties:
\begin{itemize}
    \item \emph{Dynamicity}: the direct support for opportunistic service activation and evolution is achieved through
        code mobility and constructs that define dynamic domains of computations dependent on space and time;
    \item \emph{Context-awareness}: aggregate programs utilize sensors, communication driven by neighborhood interactions,
        and iterative execution to consistently evolve the set of local contexts.
        This evolution forms the basis for the unfolding of computation and coordination logic;
    \item \emph{Co-location}: as a natural method to define the concept of neighbourhood, relies on a physical space basis.
        \ac{ac} inherently incorporates locality (both in space/time and purpose) to organise interactions and activities;
    \item \emph{Transience}: \ac{ac} provides constructs that directly supports the execution of distributed services
        based on time and context awareness.
\end{itemize}

\paragraph{Computational model}
%todo I can see this as ubiquitous language
There are some concepts and relationships included in the \emph{aggregate computing} context:
\begin{itemize}
    \item \emph{Aggregate program}: an executable representation of specific aggregate logic that defines a collective behaviour;
    \item \emph{Aggregate system}: a set of interconnected nodes or devices that support the collective execution of aggregate programs;
    \item \emph{Aggregate application}: a specific aggregate logic operating on a designated aggregate system, aimed at
        solving particular problems in a specific context;
    \item \emph{Node}: also referred to as \emph{device}, it represents an individual \ac{ac}-enabled entity, potentially
        equipped with sensors and actuators;
    \item \emph{Neighbourhood}: the logical or physical set of nodes that can be directly contacted by a given node;
    \item \emph{Global or local sensor}: a source for global or local information;
    \item \emph{Global or local actuator}: a global or local actionable device for environment-directed actions;
    \item \emph{Global or local computational environment}: anything that is detectable and subject to action through the
        use of global (or local) sensors and actuators
        This also includes the shared functionalities offered by the platform.
\end{itemize}

The networked devices inside an aggregate system compute and communicate at asynchronous rounds of execution.
Each round, each device executes the global aggregate program according to the local semantics; then it updates its internal
state and lastly generates the data for the external communication.

The round is performed by taking into account the computational context created by the previous state, sensor data and
messages from neighbouring devices.
After the execution of the round, result data are made available to neighbours and eventually instructed actuations are
locally executed.
The system can continuously react to changes by repeatedly executing rounds, allowing for self-adaptation to contextual changes.

\paragraph{Models alignment}
Due to the high-level and platform-independent metamodels of \ac{iot} and \ac{ac} systems, each with different goals or
abstraction levels, it is necessary to align the two metamodels.
This ensures that their unique focus is taken into account.

There are some main differences between the two metamodels:
\begin{itemize}
    \item the concept of device is different, for \ac{ac} is logical and is not the same as a device component of a Smart Object;
    \item although ensembles of Smart Objects are conceptualised as firs-class concept in \ac{ac}, they are not explicitly
        represented in the \ac{iot} system metamodel;
    \item the concept of neighbourhood in \ac{ac} regulates local, contextual communication among its devices.
        However, this concept cannot be explicitly mapped to \ac{iot} system concepts because device-to-device relationships
        are abstracted away from the metamodel.
\end{itemize}

\subsection{XC}
\label{subsec:xc}
\textbf{XC} is an experimental programming language design to develop \emph{homogeneous} distributed systems.
Those kinds of systems consist of similar devices that communicate to neighbours and execute the same program.
The aim of this experimental language is to push the abstraction boundaries farther than actual existing approaches.

Many issues can arise in distributed systems, like concurrency, remote communication, asynchronous execution, message
loss, and device failures.
These kinds of problems must be taken into account when designing a programming language for such systems.
Some of the possible applications of this approach may be crowd management, gossip-based data aggreation, task allocation
in robot swarms and coordination of enterprise servers. %todo add cites that are in the xc paper

The homogeneity in large-scale systems also arises when each device executes a program from a predefined set, reflecting
a homogeneous configuration featuring a single program with an initial branch.

%This design eliminates the need to handle the aforementioned problems explicitly.
%Additionally, distributed programs with independent devices retain composability through a mechanism called \emph{alignment}.

\paragraph{System model}
Devices that can send or receive messages are called \emph{neighbours}, and they can change dynamically to model network
delays, failures or spatial movements.

Based on existing homogeneous systems, the device behaviour has been abstracted through a notion of \emph{execution round},
in which a device independently executes an \textbf{XC} program and sends the resulting messages to its neighbours.
Referring to \emph{macroprogramming}, each device's behaviour in the network is developed as a single program, with no
assumption of when an execution round will occur, meaning that they are entirely asynchronous.

Messages are handled queueing up in a buffer; when a device executes its \textbf{XC} program, it processes the received
messages producing others to send to neighbours, that in turn will process their messages.
%todo insert graph of the system model

It can occur that a device executes multiple rounds before a neighbour executes its own, in that case the neighbour will
only see the last received message from the first device; newly received messages will overwrite the older ones.
Messages can persist across rounds; they are not removed from the buffer after they have been read unless they expire.
The devices for which a message is available in a certain round are considered the \emph{neighbours} for that round.

\paragraph{Data types}
\textbf{XC} features two kinds of values:
    i) \emph{local values (l)}, that include traditional types, and
    ii) \emph{neighbouring values (nvalues)}, a map from the device identifier to their local values, used to describe
        the set of values received from and sent to neighbours.
In highly decoupled networks, it can occur that not all devices will produce a value, for this reason it will be used
a default value.

Different types of operations can be applied to \emph{nvalues}, where the function passed is repeatedly applied to
neighbour's values in a field \texttt{\underline{w}}, excluding the self-value.
A \emph{local value} can be also converted to a \emph{nvalue} using the default value for every device.

\paragraph{Communication in XC}
\textbf{XC} is based on a key communication primitive: \lstinline|exchange(e_i, (n_) => return e_r send e_s)| which is evaluated
as follows.
i) the device computes the local value from the initial value~\lstinline{e_i}.
ii) the variable \texttt{\underline{n}} gets substituted with the computed nvalues \texttt{\underline{w}} of the received messages, eventually
 using the local value as default, the exchange returns the computed value \lstinline{v_r} from \lstinline{e_r}.
iii) \lstinline{e_s} evaluates to a nvalue \texttt{\underline{w}\_s} consisting of local values to be sent to neighbours,
    that will take their corresponding value from \texttt{\underline{w}\_s} and use it for the execution of their next round.

A common pattern that can be used is to access neighbour's values through the use of the \texttt{exchange} function, as follows.

\lstinline|nbr(e_1, e_s) = exchange(e_i, (n_) => return n_ send e_s)|
Which means that the value of expression \lstinline{e_s} is sent to neighbours and returns the received values gathered as
\texttt{\underline{n}} with its default, thus providing a view on neighbours' values \lstinline{e_s}.

The crucial aspect of the \textbf{XC} expressivity is that \texttt{exchange} can send a different value to each neighbour,
allowing custom interaction through them.

\paragraph{Alignment}
An aggregate program has the capability to execute multiple exchange-expressions.
In order to guarantee the dispatching of messages to corresponding expressions throughout different rounds,
    \textbf{XC} introduces the concept of \emph{alignment}.
The \emph{alignment} is a mechanism that enables developers to abstract over asynchronous execution while still retaining
composability.
In this way, \textbf{XC} guarantees that the values produced by an exchange are processed by the corresponding function
in the next round.
To accomplish this, it verifies whether it's in the same position of the Abstract Syntax Tree (AST) and of the stack frame.

\paragraph{Conditionals}
\textbf{XC} supports conditional expressions, like \lstinline|if(cond) {e1} else {e2}|.
An exchange aligns only across the devices that take the same branch; thus, it evaluates only aligned sub-expressions.
This means that a network can be split by a conditional expression into two non-communicating subnetworks, each
evaluating a different branch without cross-communication.

\paragraph{Fault tolerance}
\textbf{XC} programs are resilient to failures: in case a node gets disconnected or messages get lost, the failed node won't
show up among the neighbours of a given node in the next alignment.
The logic of \emph{exchange} is set to let neighbours' messages collectively operate, in order to make no assumptions
on their number or identity.
It is crucial to highlight that XC does not inherently offer assurances regarding fault tolerance.
As a Turing-complete language, the capability to program non-resilient behaviour is inevitably present.

\section{Motivations}
\label{sec:motivations}
%vantaggi > benefits/utility

In this section, the motivations for developing a new programming language for aggregate computing will be illustrated,
the objectives that are intended to be achieved and the benefits that are expected to be obtained.

From an engineering perspective, the construction of \ac{iot} applications differs substantially from that of traditional
software, especially when a particular service, to be realised, requires the coordination of devices of different nature.

\paragraph{Challenges and innovations}
Over the course of time, different approaches have been proposed to program these systems, such as TOTA, SAPERE, Aggregate
Computing, Linda, MARS and others. %todo cite them

The most successful solution at the moment involves the use of Cloud Computing (see Figure~\ref{fig:cloud-edge-continuum}),
which provides virtualised resources on a large scale, but presents limitations in terms of latency (due to the physical
distance between machines) and scalability (due to centralisation).

For this reason, Edge Computing and Fog Computing have recently emerged, aiming to bring resources closer to the outer
edge of the network, where interoperability problems between devices and complexity in managing distributed resources increase.

The design of applications capable of operating indistinctly on the cloud, on the edge, or even on a mesh network
(in fact, on a computational continuum that goes from the edge to the cloud) can benefit from unconventional approaches,
such as Aggregate Computing.

\begin{figure}
    \centering
    \includegraphics[width=.5\linewidth]{figures/edgecloud}
    \caption{This figure shows the continuum of computing from the edge to the cloud, highliting the edge-cloud verticality
    and the heterogeneity of devices.}
    \label{fig:cloud-edge-continuum}
\end{figure}

\subsection{Heterogeneity limitations}
\label{subsec:heterogeneity-limitations}

One of the limitations of current collective programming approaches is the management of heterogeneity.
In fact, the system assumes that there is a certain uniformity of capabilities along the continuum, or that it is possible
to abstract it in some way (see, for example, the ``pulverization'' approach).
%todo cite pulverization

However, when the system includes devices whose nature is profoundly different (imagine, for example, a system where both
well-equipped servers and tiny wearable or implanted devices with very moderate computing capabilities participate, as
shown in Figure~\ref{fig:smart-network-objects}), finer mechanisms are needed.
A somewhat analogous problem appears in functional programming when modelling effects, and recent proposals aim to capture
them in the form of capabilities.

\begin{figure} %[!ht]
    \centering
    \includegraphics[width=.8\linewidth]{figures/smart_network_objects}
    \caption{Our world is increasingly populated with a wide range of computing devices, embedded in our environment
    and with many opportunities for local and even location-indipendent interactions on fixed network infrastructures.}
    \label{fig:smart-network-objects}
\end{figure}

\subsection{Goal}
\label{subsec:goal}

The aim of this thesis is to create a unified platform that enables the use of aggregate computing techniques on
any device, from wearables with limited computing capabilities to servers.
This will allow for the definition of collective behaviour in an ergonomic language, with the service executed in a distributed manner on all devices in the network.
The result is the programming of the edge-cloud continuum as a single-distributed device.

It is necessary to rely on technologies and languages that can run on any device.
Kotlin Multiplatform will be used, which allows developers to write code that can be compiled for multiple targets,
including JVM (ideal for server environments), Javascript (browser), Android, iOS (including watchOS and tvOS), and native versions
(for Windows, MacOS, and Linux, both for x86 and ARM CPUs).

Once implemented, the system will enable the writing of pure Kotlin code using a dedicated domain-specific language.
This will be followed by the production of deployment units in the formats described above.
To run any of these units on a supported device, the device must be connected to the service.

\paragraph{Impact}
The availability of a distributed programming and execution infrastructure that supports heterogeneous devices is crucial
for the realisation of Distributed Digital Twins.

These represent a significant evolution in the way we conceive the digital representation of objects and complex systems.
In a traditional context, a Digital Twin is a digital replica of a physical object or system used to monitor and analyse
its operation in real-time.

However, the distributed approach takes this concept to a new level.
Instead of focusing solely on specific objects, the Distributed Digital Twin encompasses entire organisations of people
or interconnected object systems.
This allows for a unified view of objects and hierarchies (or holarchies) of objects.

The interaction between these entities is presented in an integrated and unified manner, resulting in greater conceptual
coherence, efficiency, and understanding of the digital environment.
This, in turn, facilitates the engineering of complex systems.
The objective of this project is to simplify the engineering process in order to innovate the landscape of digital infrastructures.
This will open the doors to new services that would otherwise be challenging to conceive, design, and scale.

\section{State of Art}
\label{sec:state-of-art}

In this section, it will be presented the state of the art in the field of aggregate computing, focusing on the main existing
frameworks and languages and their limitations.

Still, in terms of portability to heterogeneous systems, there are currently several software programs that implement the
semantics of aggregate programming derived from field calculus [15], but they are not interoperable with each other.

\subsection{ScaFi}
\label{subsec:scafi}
%todo cite scafi
%todo cite scafi web
%todo cite alchemist

% components: core (it support a variant of field calculus called F ScaFi), simulator, gui, actor-based runtime
% where it is used: swarm (macroswarm), crowd management, WSN/smart city (paper IEEE mio)
% integrated with alchemist
% why: pratical use, extensible, fast-use thanks to scafi web (gianlu sempre presente)

\emph{ScaFi (Scala Field)} is a Scala-based framework for aggregate programming.
It provides a \emph{\ac{dsl}}, libraries, a simulation environment with a GUI, integrated with the
Alchemist simulator, and an actor-based runtime for the development of aggregate computing-based systems.
\emph{ScaFi}'s core is based on a variant of the \emph{field calculus} called \emph{F ScaFi}, which peculiarity
is to handle standard values to provide a simplified setting for \ac{dsl} embedding.

This is achieved by introducing a notion of ``computation against neighbours'', meaning that is a computation whose
output depends on the most recent values received from neighbours.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/scafi_structure}
    \caption{High-level architecture of the ScaFi toolkit.}
    \label{fig:scafi-structure}
\end{figure}
%todo cite ref image

The architecture of \emph{ScaFi} consists of various modules, as seen in Figure~\ref{fig:scafi-structure}.
The \ac{dsl} and standard library of reusable functions are implemented in the \texttt{scafi-
core} module; meanwhile, the modules \texttt{scafi-simulator} and \texttt{scafi-simulator-gui} provide a simulation
environment of aggregate systems with a graphical user interface.

%todo cite Addressing Collective Computations Efficiency: Towards a Platform-level Reinforcement Learning Approach
%todo cite Programming (and Learning) Self-Adaptive & Self-Organising Behaviour with ScaFi: for Swarms, Edge-Cloud Ecosystems, and More
The main applications of \emph{ScaFi} are in the development of swarm systems, crowd management, wireless sensor network (WSN)
and smart city applications.

\emph{ScaFi} is capable of running aggregate programs on the \ac{jvm} and also on web browser thanks
to the \emph{ScaFi Web} tool, which allows the rapid prototyping of aggregate programs.
On the other hand, it does not provide an aggregate standard library in the public version, neither supports to
different advanced mechanisms.
Furthermore, it is based on Scala 2, which means that it needs a review to be updated to Scala 3.

Since \emph{ScaFi} only supports \ac{jvm} and web-based applications, it is not well-suited for the development of complex distributed systems.
devices and communication technologies, such as thin devices that do not support \ac{jvm}, which limits the heterogeneity of
devices that can be used in the system.

\subsection{Protelis}
\label{subsec:protelis}
%todo cite protelis, Java. xtext,
\emph{Protelis} is a functional programming language that implements a higher-order version of the \emph{field calculus},
exposed through a C-like syntax, enabling the construction of widely reusable components of aggregate systems.
It also provides various domain-specific APIs that are interoperable with Java.
\emph{Protelis} has been developed since no foundational API for resilient, situated and distributed systems can be found
in the Java ecosystem.
It offers an implementation for the interoperability with the \emph{Alchemist} simulator, where it can be seen its
practical use in the development of aggregate systems.

%todo insert protelis architecture image

As seen in the \emph{Protelis} architecture, an interpreter executes a pre-parsed program at regular intervals,
that communicates with other devices and draws contextual information from the environment.
This is instantiated by specifying when the executions occur, how the devices communicate and how the environment is
represented.

A key reason for this choice is that Java is highly portable across systems and devices.
Another important reason is that Java's reflection mechanisms make it easy to import a large number of useful libraries
and APIs for use in Protelis.

It is based on \emph{Xtext}, a framework for the development of domain-specific languages, which provides a set of tools
and libraries for the development.
For this reason necessary requires a \ac{jvm} to run, which limits the heterogeneity of devices
that can be used in the system.

\subsection{FCPP}
\label{subsec:fcpp}
\emph{FCPP} is an implementation of the \emph{Field Calculus} as a C++ library, with tools for simulations of distributed systems.
This library is built as a component-based system, with the aim of being easily extensible and reusable in different contexts.

It has a performance-oriented implementation based on compile-time optimisations, and it is designed to support
simulated systems executed in parallel or self-organising cloud application.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/fcpp-structure}
    \caption{The Software architecture of FCPP represented as three main layers.}
    \label{fig:fcpp-structure}
\end{figure}
%todo cite ref image

Being implemented in C++, allows \emph{FCPP} to be used in a wide range of devices, including embedded systems and
microcontrollers, for which a C++ compiler is available.
Although \emph{FCPP} is designed as a flexible and easily extensible platform, its currently supported range of features
is more limited than \emph{Alchemist}'s.

It allows running aggregate programs on low computational capacity devices.
However, its syntax is less ergonomic compared to other languages, making it unlikely to reach a mainstream developer audience.

\paragraph{Final considerations}
Those three illustrated frameworks have more or less the same expressive power, with few notable differences.
The main differences among them are between \emph{ScaFi} and \emph{FCPP}, that are \emph{internal} \ac{dsl} implemented in Scala
and C++, and \emph{Protelis} that is an \emph{external} \emph{dsl}, interpreted in the \ac{jvm}.

Considering their syntax, \emph{ScaFi} and \emph{Protelis} partially imitate the abstraction level of the \emph{field calculus},
being bound by the specific syntactic constraints of their host languages.
Whereas, \emph{Protelis}' syntax is more neat and specifically designed for field computation.

However, the more complex syntax of Scafi and FCPP may prove easier to learn for programmers already familiar with Scala and C++.