%! Author = angela
%! Date = 24/01/24
% !TeX root = ../thesis-main.tex
\definecolor{ddarkgreen}{rgb}{0,0.5,0}
\lstdefinelanguage{kt}{
    frame=single,
    basewidth=0.5em,
    language={kotlin},
    keywordstyle=\color{blue}\textbf,
    commentstyle=\color{ddarkgreen},
    keywordstyle=[2]\color{cyan},
    keywords=[2]{Aggregate, Field,InboundMessage, OutboundMessage, SingleOutboundMessage,Message,Path,YieldingScope,Network,State,
        AggregateContext,AggregateResult,YieldingContext,YieldingResult},
    keywordstyle=[3]\color{orange},
    keywords=[3]{exchange,exchanging,repeat,repeating,share,sharing,neighboringViaExchange,Collektive,aggregate,yielding},
    keywordstyle=[4]\color{teal}\textbf,
    keywords=[4]{ID,Scalar,Initial,Return,Payload,*,R,X,Init,Ret},
    keywordstyle=[5]\color{olive},
    keywords=[5]{read,mapTo,stateAt,messagesAt,newField,excludeSelf,currentPath,mapToConstantField,getPosition,map,distanceTo},
    keywordstyle=[6]\color{blue},
    keywords=[6]{also,it,run,let}
}

\chapter{Contributions}
\label{ch:contributions}
In this chapter, will be presented the main contributions of this thesis.

\section{Collektive}
\label{sec:collektive}

\emph{Collektive} is a framework designed to simplify the definition of \ac{ac} systems.

The main objective of this technology is to facilitate the development of aggregate programs that can be executed on a
variety of computing systems, such as mobile and wearable devices, computers, and the cloud.
This allows for interoperability and communication between these systems, despite their different nature.

To achieve this, \emph{Collektive} uses the \ac{fc} model to provide a straightforward and intuitive method for defining
an aggregate program, without the need for low-level coding.
In addition, \emph{Collektive} has been developed to be multiplatform, so it can be executed on different systems thanks
to the use of \emph{Kotlin Multiplatform}.

As for the feature solution of alignment for the correct functioning of aggregate programming,
it has been developed a compiler plugin with the purpose of annotating the functions that are aligned;
those paths will be used for the actual alignment of the nodes.

\paragraph{Project Structure}
The project is subdivided into different submodules (as in \Cref{fig:pacakges}), each with a specific purpose:

\begin{enumerate}
    \item \textbf{alchemist-incarnation-collektive}: contains the pieces for the Alchemist integration,
        in order to run the aggregate programs created with Collektive on the simulator.
    \item \textbf{dsl}: is the core of the project, contains the actual implementation of the logic and the \ac{ac} operators
        and relative tests.
    \item \textbf{plugin}: subdivided into:
        \begin{enumerate}
            \item \emph{gradle-plugin}: used by gradle project in order to use the \emph{compiler-plugin}.
            \item \emph{compiler-plugin}: used to keep tracks of the stack at runtime, foreach aggregate program.
        \end{enumerate}
    \item \textbf{buildSrc}: contains the main configuration for running the multiplatform project.
\end{enumerate}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/packages}
    \caption{Packages diagram of the Collektive project.}
    \label{fig:pacakges}
\end{figure}

Regarding the examples, there is a specific repository called \textbf{collektive-examples} that contains some samples of
aggregate programs to show how to use the \emph{Collektive} framework.

\section{DSL}
\label{sec:dsl}

In this thesis, the original implementation of the \ac{dsl} of \emph{Collektive} will be modified to allow the use of \xc{}
and to improve its performance.

A \ac{dsl} is a specialised programming language or language framework tailored to address the
requirements of a specific domain or problem area.
In contrast to general-purpose programming languages, which aim for versatility across various domains and problem categories,
DSLs are crafted to cater precisely to the demands of a particular application or system.
Consequently, general-purpose languages like Java typically exhibit greater complexity compared to \acp{dsl}.


\paragraph{Structure}
%todo add class diagrams
%For what it concerns the structure of the core of the project,
The \emph{Collektive}'s \ac{dsl} is composed of the following components:
\begin{itemize}
    \item \textbf{Path}: represents a specific point in the \ac{ast} of an aggregate program;
    \item \textbf{State}: is an association between a path and a value, it is used by the compiler plugin to
        keep track of the computational state of the device in order to provide the correct alignment of the nodes;
    \item \textbf{Field}: represents the \emph{computational field} used by aggregate constructs.
        It is a map of messages where the key is the identifier (ID) of the node, and the value is the associated message;
    \item \textbf{Message}: is an interface that represents the message exchanged between nodes, its concept will be explained in \ref{subsec:messages};
    \item \textbf{Network}: is the interface that represents the network used to manage the communication between devices;
    \item \textbf{Aggregate}: the actual core of the \ac{dsl}.
        It is also used to handle all the data needed for the computation; for example, the \emph{localId} and the \emph{state} of the device.
        It contains the primary functions on which the language is extended, such as \texttt{exchange}, \texttt{exchanging}, \texttt{repeat} and \texttt{repeating};
        To create an aggregate program, a function must extend this interface, in this way it will be possible to use the aggregate functions.
        It is also implemented the mechanism to handle the alignment of the functions used within the compiler plugin;
    \item \textbf{AggregateOperators}: contains the implementation of the functions created using the \texttt{exchange-exchanging} functions,
        such as \texttt{share}, \texttt{sharing} and \texttt{neighboringViaExchange}.
        Moreover, it contains the mechanism to manage the alignment of the fields used within the compiler plugin;
    \item \textbf{YieldSupport}: contains the \emph{Yielding Context} and the \emph{Yielding Result} for the ``yielding''
        operations, which means that the function operates on an initial value but possibly returns a different value;
    \item \textbf{Collektive}: is the entrypoint for creating a ``Collektive'' device, it must have a specific \emph{ID} and a
        \emph{network} to manage the communication between devices.
        The effective aggregate program is identified by the \emph{compute function}, which will be executed
    \item \textbf{AggregateResult}: is the result of one evaluation of the aggregate program, it contains the \emph{localId}
        of the node, the effective \emph{result} of the computation, the \emph{messages to send} to other devices and the \emph{new state} of the device;
\end{itemize}

\subsection{XC in Collektive}
\label{subsec:exchange-in-collektive}

Thanks to the design of \xc{}, it is possible to implement the methods proposed by \emph{field calculus}
(~\ref{par:syntax-of-field-calculus}) in terms of \emph{exchange} (~\ref{par:communication-in-xc}).
The syntax of \emph{XC} allows for sending messages to specific nodes, enabling the implementation of \emph{field calculus}
operations through message exchange.

The \emph{exchange} communication is based on \emph{anisotropic} communications, meaning that it has not the same properties
or characteristics in all directions (\Cref{fig:anisotropic}); therefore, messages have custom values sent to different neighbours.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.2\textwidth]{figures/anisotropic}
    \caption{Anisotropic communication.}
    \label{fig:anisotropic}
\end{figure}

This concept can be extended to the \texttt{share} function of field calculus, with the difference that the
operation of \texttt{share} is based on \emph{isotropic} communication, meaning that properties are uniform in all directions
(\Cref{fig:isotropic}); therefore, messages have the same value sent to all neighbours.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.2\textwidth]{figures/isotropic}
    \caption{Isotropic communication.}
    \label{fig:isotropic}
\end{figure}

All the \ac{dsl} has been modified to use \texttt{exchange} for the implementation of the other constructs such as \texttt{share}
and \texttt{nbr}, which is called \texttt{neighboring}.
Only the \texttt{rep} construct has not been implemented in terms of \texttt{exchange}, as it is a function that allows iterating
over oneself, it's better for neighbours not to receive messages of any kind, also for security and privacy reasons.
As the original implementation, it supports the evaluation of \emph{fields}.

\paragraph{Exchange}
The construct \texttt{exchange} provides
    \emph{(i)} access to neighbours' values,
    \emph{(ii)} persistence of information for subsequent executions,
    \emph{(iii)} communication with neighbours, and
    \emph{(iv)} compositional behaviour.

As seen in \ref{par:communication-in-xc}, the \texttt{exchange} function can send and return the same result, or it
can send a message and return a different result; both cases have been implemented.

%todo check that I say that the return is a field
%todo diagrams?

The \texttt{exchange} takes an \emph{initial} value to use as a default, and a \emph{body} that defines an aggregate
function to be computed, as seen in the code snippet \ref{lst:exchange}, returning a \emph{field}.
When executing the aggregate program, it checks which messages have been received from the neighbours and applies the function,
generating a custom value for each neighbour.

In the early stages of the design of this function, potential problems that could arise during execution were evaluated,
such as the management of initialisation, i.e.\ the first round of message exchange.
Consider a network consisting of $n$ devices, in which all are considered as neighbours to each other.
The first device ($d_1$) to start within the network will certainly have a moment when it performs its first iteration ever.

The problem arises when the device $d_1$ has not yet received any messages, so it will not have neighbour values to perform
the calculation, thus creating a deadlock situation where it does not know the neighbourhood and does not know who to actually send a message to.
For this reason, it was necessary to implement a mechanism such that the device performs a first iteration on its initial value,
and send the message to the network without a specific recipient, so that the future ``neighbourhood'' can receive it and start a communication with $d_1$.
In this way, the next devices to ``wake up'' in the network will know that $d_1$ is present and will be able to communicate with it.

\begin{lstlisting}[language=kt,label={lst:exchange}, caption={The signature of the \texttt{exchange} function.}]
fun <Initial> exchange(
    initial: Initial,
    body: (Field<ID, Initial>) -> Field<ID, Initial>,
): Field<ID, Initial>
\end{lstlisting}

\paragraph{Share}
The \texttt{share} construct captures the space-time nature of field computation through observation of neighbours' values,
starting from an \emph{initial} value, it reduces to a single local value given a \emph{transform} function and updating and sharing to
neighbours of a local variable, then returns the punctual value evaluated from the transformation (\ref{lst:share}).

\begin{lstlisting}[language=kt,label={lst:share}, caption={The signature of the \texttt{share} function.}]
fun <ID : Any, Initial> Aggregate<ID>.share(
    initial: Initial,
    transform: (Field<ID, Initial>) -> Initial,
): Initial
\end{lstlisting}

As previously introduced, this construct can be expressed in terms of \texttt{exchange}.
What \texttt{share} differs from it is that \texttt{share} does not differentiate the result of the computation based on
the neighbour that sent the message; it sends it indiscriminately to all neighbours.

\paragraph{Neighboring}

The \emph{field calculus} construct \texttt{nbr} is implemented as \texttt{neighboring}, more precisely as \texttt{neighboringViaExchange}
due to its effective implementation based on the \texttt{exchanging} function.
The \texttt{neighboringViaExchange} construct is used to access the values of the neighbours.
It takes as parameter \emph{local} (\ref{lst:neighboring}), which can be an expression or a value, and returns a \emph{field} of the same input type.

\begin{lstlisting}[language=kt,label={lst:neighboring}, caption={The signature of the \texttt{neighboringViaExchange} function.}]
fun <ID : Any, Scalar> Aggregate<ID>.neighboringViaExchange(
    local: Scalar,
): Field<ID, Scalar>
\end{lstlisting}

%todo add something else???

\paragraph{Repeat}
The \texttt{repeat} function is the equivalent of the \texttt{rep} construct in \emph{field calculus}.
It models the state evolution over time, the value of \emph{initial} evolves at each execution depending on the \emph{transform} function,
and it returns the final value of the computation (\ref{lst:repeat}).

\begin{lstlisting}[language=kt,label={lst:repeat}, caption={The signature of the \texttt{repeat} function.}]
fun <Initial> repeat(
    initial: Initial,
    transform: (Initial) -> Initial,
): Initial
\end{lstlisting}

As previously mentioned, this function is not implemented in terms of \texttt{exchange}, because iterating over oneself
it is better not to send messages to neighbours, also for security and privacy reasons, its implementation will be explained in \ref{par:repeating}.

\subsection{Messages}
\label{subsec:messages}
%todo message modelling (in scafi there is an action that computes the messages and then creates a reaction that
%sends the message) we do it in a different way

The accurate modelling of message functionality is crucial for device communication.
Due to the different nature of messages supported, that is \emph{anisotropic} and \emph{isotropic} communication,
it has been necessary to create specific data classes for the handling of relative messages.

Previously, messages were sent to the network without considering the recipient, and the network was responsible for
delivering the message to all the neighbours that were interconnected.
Since the main feature of \texttt{exchange} is to send messages to specific neighbours with custom values, it is important
to ensure that unintended recipients do not receive the message.
Therefore, the old model of messages has been modified.

\paragraph{OutboundMessage and SingleOutboundMessage}
It has been introduced the concept of \emph{OutboundMessage} (\Cref{lst:outbound}), which is a data class that keeps track of the sender of the
message (its ID), and a map of messages, where the key is the \emph{Path} of the computation and the value is another data
class: the \emph{SingleOutboundMessage} (\Cref{lst:single}).
In this way, a device sends to the network just one \emph{OutboundMessage} that contains all the messages to send to the neighbours,
and also unburdens the payload of the network.

\begin{lstlisting}[language=kt,label={lst:outbound}, caption={Outbound message data class.}]
data class OutboundMessage<ID : Any>(
    val senderId: ID,
    val messages: Map<Path, SingleOutboundMessage<ID, *>>,
) : Message
\end{lstlisting}

\begin{lstlisting}[language=kt,label={lst:single}, caption={Single outbound message data class.}]
data class SingleOutboundMessage<ID : Any, Payload>(
    val default: Payload,
    val overrides: Map<ID, Payload>,
)
\end{lstlisting}

The main difference for the type of the communication lies in the \emph{SingleOutboundMessage} data class.
For what it concerns the \emph{anisotropic} communication, it is necessary to keep track of the identifier of the recipient
and the value associated with it, in order for the network to deliver the message to the correct neighbour.
This has been implemented with a map of \emph{overrides}, which associates to the recipient's identifier a specific value.

For the \emph{isotropic} communication, the \emph{SingleOutboundMessage} has a \emph{default} value, which is used
when there are no overrides for the recipient that is reading the messages received.

In summary, when a program is executed and a device has computed its function, it has to generate the messages to send to
the neighbours (so it's done inside the \texttt{exchange} function), it populates a \emph{SingleOutboundMessage},
that will be added to a list of \emph{OutboundMessage} and sent to the network.

\paragraph{InboundMessage}
The \emph{InboundMessage} is a data class (\Cref{lst:inbound}) modelled for the messages read from the network.
When reading the \emph{OutboundMessage}, there are some fields that are not needed, such as the receiver of the message,
which is the device itself, and is necessary to keep the default value or the override value.
To handle this, the \emph{InboundMessage} has been modelled to keep only the identifier of the sender and
a map of messages of \emph{Path} and the associated value.

\begin{lstlisting}[language=kt,label={lst:inbound}, caption={Inbound message data class.}]
data class InboundMessage<ID : Any>(
    val senderId: ID,
    val messages: Map<Path, *>,
) : Message
\end{lstlisting}

\subsection{Network}
\label{subsec:network}
The \emph{Network} has the task of managing only the reading and writing of messages in the network for a single device.
The actual implementation of the network is not managed by \emph{Collektive}, but it is the user's responsibility to manage
the network according to their needs.

In the \ac{dsl}, it is used at the beginning of an iteration of the aggregate program to read the messages received from
other devices present in the network, and at the end of the iteration to write the messages to send to the other devices.
The network actually supports only the specific types of messages introduced in \Cref{subsec:messages}, due to the
concepts introduced by the study of \xc{} and field calculus.

\section{Plugin Extensions}
\label{sec:plugin-extensions}
In Kotlin, a plugin compiler extension refers to a mechanism that allows developers to extend or customise the behaviour
of the Kotlin compiler.
These extensions provide a way to hook into the compilation process and modify or enhance the way Kotlin code is compiled.

Developers can create their own compiler extensions by implementing the necessary interfaces or annotations defined by
the Kotlin compiler API.
These extensions can then be applied to Kotlin projects either globally or selectively, depending on the specific
requirements of the project.

In Kotlin multiplatform project development, the compiler undertakes a covert translation of Kotlin code into platform-specific code.
Prior to this translation, the Kotlin code undergoes conversion into an \ac{ir}.
This IR serves as a transitional format, facilitating the seamless creation of multiplatform compiler plugins.
Notably, this approach eliminates the necessity to develop separate plugins for each platform, thus optimising the
development process and fostering code reuse across varied environments.

Since the source code is fully accessible at compile time, it becomes feasible to analyse it to determine when alignment
is necessary for the plugin to comprehend; consequently, new code can be generated to ensure proper alignment.
Furthermore, because the generation process is based on the intermediate representation, it enables interoperability across
different project targets and devices running on the same platform.
Modifications to the plugin are applied during compile time, minimising any notable impact on execution time.
Lastly, users are shielded from the intricacies of alignment concerns, as the code generation process remains transparent to them.

%todo why in scafi alignment is problematic (catching exception thrown)

\paragraph{Alignment}

%In ScaFi (\Cref{subsec:scafi}), the alignment of an aggregate program is made by catching the exception thrown by

In \emph{Collektive}, the alignment of the functions is made by the compiler plugin, which keeps track of the sequence of
functions called during the computation, using a custom stack.
The function name is pushed into the stack when the function is called, with a value appended that represents the occurrence of the
function in the sequence of the computation; then it is popped when the control flow exits that function.
A function to be aligned must have as extension receiver or as argument's type the \emph{aggregate context}.

The \texttt{alignedOn} function is used to push in the stack the pivot, which is the identifier on which the alignment is based.
Executes a body and returns the result of the computation, then resets the stack to the previous state.
The compiler plugin uses the \ac{ir} to retrieve the \texttt{alignedOn} function declaration and the \emph{aggregate context}.
After that, it visits through the visitor pattern all the functions call looking for the \texttt{Aggregate} super type.

%todo alignment dei field
%piu esempietti
%snippet di come funziona e come il plugin allinea le funzioni


\section{Technologies}
\label{sec:technologies}
%multiplatform
%todo
%todo write something somewhere about the readability of the code

\paragraph{Kotlin Multiplatform}
\label{par:kotlin-multiplatform}

\emph{Kotlin Multiplatform} is a technology that allows developers to write code that can be shared across multiple platforms,
such as Android, iOS, web, desktop, and backend.
It enables developers to write common business logic, data models, and utility functions once and then use them across
different platforms, reducing code duplication and improving code maintainability.

\emph{Kotlin Multiplatform} enables significant code reuse across multiple platforms, leading to faster development cycles,
reduced maintenance efforts, and improved code consistency.
\emph{Kotlin Multiplatform} supports compilation targets for various platforms, including Kotlin/JVM for backend and desktop applications,
Kotlin/JS for web applications, and Kotlin/Native for Android, iOS, and other native platforms.
Developers specify the compilation targets in the Gradle configuration to generate platform-specific binaries.

\paragraph{Kotest}
\emph{Kotest} is a powerful testing framework for Kotlin that provides a flexible and expressive way to write tests for Kotlin projects.
It offers a rich set of features and utilities to make testing easier, more concise, and more effective.

\emph{Kotest} provides a wide range of built-in matchers and assertion functions for common test scenarios, such as equality
checks, collection assertions, exception handling, and more.
These utilities make it easy to write expressive and accurate assertions without boilerplate code.
Some tests example will be shown in \Cref{ch:validation}.

\paragraph{Gradle}
Gradle is a powerful build automation tool and dependency management system used primarily for Java, Kotlin, and Groovy projects.
It is designed to be highly flexible, scalable, and efficient, making it a popular choice among developers and
organisations for building and managing software projects.

Gradle uses a declarative \ac{dsl} based on Groovy or Kotlin to define build scripts.
This DSL allows developers to express build configurations, tasks, dependencies, and plugins in a concise and readable format.
Gradle build scripts are typically named build.gradle and are written in Groovy or Kotlin.

Gradle organises the build process around tasks, which are units of work that perform specific actions, such as compiling
source code, running tests, or generating documentation.
Developers can define custom tasks and dependencies between tasks in the build script, allowing for fine-grained control over the build process.
Gradle executes tasks in parallel when possible, leveraging multi-threading to improve build performance.

\section{Implementation}
\label{sec:implementation}
In this section, the actual implementation of the \ac{dsl}'s functionalities will be examined, with code examples and explanations
regarding the implementation choices and the problems encountered during development.

\subsection{Fields}
\label{subsec:fields}
%todo explain the thing of constant fields and why is better for performances
About the manipulation of the \emph{neighbouring values} introduced in \Cref{par:data-types}, it has been implemented
the concept of \emph{Field} to handle the data structure to send between neighbours.

The \emph{Field} keeps track of the identifier of the device (\texttt{localId}) and the value associated with it
(\texttt{localValues}) and eventually a map that associates the identifiers of the neighbours to their exchanged local values.
%todo altro

\subsection{Collektive entrypoint}
\label{subsec:collektive-entrypoint}
The public entrypoint of the \ac{dsl} is the \emph{Collektive} class, which can be interpreted as a device that can
execute an aggregate program.

As seen in the code snippet \ref{lst:collektive}, the \emph{Collektive} class takes as parameters the \emph{localId} of the device,
the \emph{network} used to manage the communication between devices, and the \emph{computeFunction} that will be executed
when the device is ready to compute the aggregate program.

\begin{lstlisting}[language=kt,label={lst:collektive}, caption={The signature of the \texttt{Collektive} class.}]
class Collektive<ID : Any, R>(
    val localId: ID,
    private val network: Network<ID>,
    private val computeFunction: Aggregate<ID>.() -> R,
)
\end{lstlisting}

The aim of this class is to manage the logic and the effective execution of the rounds of the aggregate program passed as a parameter.

It provides two main functions that will be called in the incarnation to execute the program:
\begin{itemize}
    \item \texttt{cycle}: applies once the \emph{computeFunction} and returns the result of the computation;
    \item \texttt{cycleWhile}: applies the \emph{computeFunction} while the condition passed as parameter is satisfied,
        and returns the result of the computation.
\end{itemize}

Both functions are implemented through a private function \texttt{executeRound}, which effectively calls the aggregate program,
managing the result obtained and updating the internal state of the device.

There are two types of aggregate programs: one that uses the \emph{Network} and one that does not, but directly takes
a set of \emph{InboundMessage}.

\begin{lstlisting}[language=kt,label={lst:aggregate}, caption={The signature of the \texttt{aggregate program}.}]
fun <ID : Any, R> aggregate(
        localId: ID,
        network: Network<ID>,
        previousState: State = emptyMap(),
        compute: Aggregate<ID>.() -> R,
    ): AggregateResult<ID, R> = with(AggregateContext(localId, network.read(), previousState)) {
        AggregateResult(localId, compute(), messagesToSend(), newState()).also {
            network.write(it.toSend)
        }
    }
\end{lstlisting}

The code seen in \ref{lst:aggregate} is the implementation of the \texttt{aggregate} function that relies on the \emph{Network}.
Taking the \emph{AggregateContext} as context with the messages read from the network and the previous state of the
device, it applies the \emph{compute} function.
The result of the computation is then returned as an \emph{AggregateResult} (\Cref{lst:aggregateresult}), which contains the \emph{localId} of the device,
the effective \emph{result} of the computation, the \emph{messages to send} to other devices and the \emph{new state} of the device.
Finally, the messages to send are written to the network.
This is the function called from the \texttt{executeRound} function.

\begin{lstlisting}[language=kt,label={lst:aggregateresult}, caption={The signature of the \texttt{aggregate result}.}]
data class AggregateResult<ID : Any, R>(
    val localId: ID,
    val result: R,
    val toSend: OutboundMessage<ID>,
    val newState: State,
)
\end{lstlisting}

\subsection{Yielding Support}
\label{subsec:yielding-support}
In order to make possible to operate on an initial value but possibly return a different value, it has been introduced
the concept of \emph{yielding}.
The operations of yielding are used to operate on an initial value, which is usually exchanged with the neighbours,
but possibly return a different value to the caller.
This operation is executable on the \texttt{exchanging}, \texttt{sharing} and \texttt{repeating} methods, or it can be omitted
in case the value obtained from the operation is to be returned.
Those constructs will be explained in detail in the sections \ref{subsec:aggregate-context} and \ref{subsec:aggregate-operators}.

\begin{lstlisting}[language=kt,label={lst:yieldingcontext}, caption={The signature of the \texttt{yielding context} class.}]
class YieldingContext<Initial, Return> {
    fun Initial.yielding(toReturn: () -> Return): YieldingResult<Initial, Return> =
        YieldingResult(this, toReturn())
}
\end{lstlisting}

%todo explain the yielding thing


\subsection{Aggregate Context}
\label{subsec:aggregate-context}

The \emph{AggregateContext} class is the class that effectively has the implementation of the basic constructs inside the \ac{dsl}.
Internally, it keeps track of the {stack}, the state, and the messages that need to be sent by that device.

\paragraph{Exchange}
There are two versions of this construct: one that has the same type of value of the field in output as the one in input (\Cref{lst:exchangeImpl}),
and one in which they differ (\Cref{lst:exchanging}).
The \texttt{exchange} construct is the one that represents the communication in which $e_r$ (the value to return)
and $e_s$ (the value to send) coincide, as illustrated in \ref{par:communication-in-xc}.

\begin{lstlisting}[language=kt,label={lst:exchangeImpl},caption={The implementation of the \texttt{exchange} function.}]
override fun <X> exchange(initial: X, body: (Field<ID, X>) -> Field<ID, X>): Field<ID, X> =
        exchanging(initial) { field -> body(field).run { yielding { this } } }
\end{lstlisting}

The \texttt{exchange} therefore simply calls the \texttt{exchanging}, but as the context of the yielding it passes the
field on which the computation has been executed.

The real functioning of \xc{} relies in the \texttt{exchanging} implementation, which is the one that effectively manages
the actual logic of the computation and the messages to send to the neighbours.

In the \Cref{lst:exchanging} snippet is shown how the \texttt{exchanging} function is implemented.
First, it takes the current path from the stack kept inside the context and the messages received whose path is the same,
so that it is possible to evaluate only aligned messages.
Then it takes the state of the device at the current path, using the initial value passed as a parameter in case there is no previous state.
A new field is then created on which to perform the computation, starting from the value of the state and the messages received at the current path.
If there are no messages received at the current path, simply there will be an empty map of messages.
The new field is then passed to the body passed in input, along with a new \emph{yielding context}, on which the computation is effectively executed.
The result obtained from the computation is then returned and, depending on what has been passed as a yielding context in the body,
the value is sent to the neighbours, which can be either the result of the computation (in the \texttt{retsend} case) or a value of a different type.

A message of type \emph{SingleOutboundMessage} is created, populated with the value obtained from the application to the field
of the aggregate function put as the default value, while as an override it is evaluated what type of field has been
obtained from the computation, and based on this the value is sent to the neighbours.
If the field is of a constant type, the map of overrides will be empty, otherwise the value obtained from the computation
is sent, excluding the value of the device itself.
A check is made to verify that there are no messages aligned with the same path, as this could cause an alignment conflict.
Finally, the message is added to the map of messages to be sent, and the state of the device is updated with the value obtained from the computation.

\begin{lstlisting}[language=kt,label={lst:exchanging},caption={The implementation of the \texttt{exchanging} function.}]
override fun <Init, Ret> exchanging(
    initial: Init,
    body: YieldingScope<Field<ID, Init>, Field<ID, Ret>>,
): Field<ID, Ret> {
    val path = stack.currentPath()
    val messages = messagesAt<Init>(path)
    val previous = stateAt(path, initial)
    val subject = newField(previous, messages)
    val context = YieldingContext<Field<ID, Init>, Field<ID, Ret>>()
    return body(context, subject).also {
        val message = SingleOutboundMessage(
            it.toSend.localValue,
            when (it.toSend) {
                is ConstantField<ID, Init> -> emptyMap()
                else -> it.toSend.excludeSelf()
            },
        )
        check(!toBeSent.messages.containsKey(path)) {
            """
                Aggregate alignment clash by multiple aligned calls with the same path: $path.
                The most likely cause is an aggregate function call within a loop
            """.trimIndent()
        }
        toBeSent = toBeSent.copy(messages = toBeSent.messages + (path to message))
        state += path to it.toSend.localValue
    }.toReturn
}
\end{lstlisting}

%todo spiega come si comporta se non ci sono messaggi allineati

%todo explain that is a bit different from how it has been implementated in scafi, for the thing that there it loose a round of communication

\paragraph{Repeat}
\label{par:repeating}
The \texttt{repeat} construct is the one that models the state evolution over time.
It is not implemented in terms of \texttt{exchange}, as it is a function that allows iterating over oneself,
it can directly update its internal state without sending messages to neighbours.

The \texttt{repeat} construct takes as parameters the \emph{initial} value and the \emph{transform} function, and returns the
final value of the computation of the same type as the initial.
To return a different type, it has been implemented the \texttt{repeating} function, as for the \texttt{exchange} construct,
using the \emph{yielding support} (\Cref{lst:repeating}).

\begin{lstlisting}[language=kt,label={lst:repeating},caption={The implementation of the \texttt{repeating} function.}]
 override fun <Initial, Return> repeating(
    initial: Initial,
    transform: YieldingScope<Initial, Return>,
): Return =
     transform(YieldingContext(), stateAt(stack.currentPath(), initial))
        .also { state += stack.currentPath() to it.toReturn }
        .toReturn
\end{lstlisting}

The \texttt{transform} function is applied to the state of the device, checking whether there are already values to use
on the stack, or using the initial value passed as a parameter.
After the computation, the stack is updated with the new value obtained from the computation, and the result is returned,
depending on the yielding context passed in the body of the function.

%todo project function???

\subsection{Aggregate Operators}
\label{subsec:aggregate-operators}
The functions implemented using the \texttt{exchange} mechanism are situated in a separate class called \emph{AggregateOperators}.

\paragraph{Share}
The \texttt{share} is also implemented with the \emph{yielding support} mechanism, using the same base concept as in the
\texttt{exchange} and \texttt{repeat} functions.
This means that it is possible to operate on an initial value, but possibly return a different value, as seen in the code snippet \ref{lst:sharing}.

\begin{lstlisting}[language=kt,label={lst:sharing},caption={The implementation of the \texttt{sharing} function.}]
fun <ID : Any, Initial, Return> Aggregate<ID>.sharing(
    initial: Initial,
    transform: YieldingContext<Initial, Return>.(Field<ID, Initial>) -> YieldingResult<Initial, Return>,
): Return = exchanging(initial) { field: Field<ID, Initial> ->
    with(YieldingContext<Initial, Return>()) {
        val result: YieldingResult<Initial, Return> = transform(field)
        field.map { result.toSend }.yielding {
            field.map { result.toReturn }
        }
    }
}.localValue
\end{lstlisting}

Given the \emph{isotropic} nature of communication through \texttt{share}, the implementation via \texttt{exchange} is done
in such a way as to send the same value to all neighbours, so there is no need to keep track of who sent the message,
but only to send it to all neighbours.
The value sent to the neighbours can be the value expressed thanks to the \texttt{yielding} function, or the value obtained
from the computation, if the \texttt{share} function is used.

\paragraph{NeighboringViaExchange}
The \texttt{neighboringViaExchange} construct is used to access the values of the neighbours.
It takes as parameter \emph{local}, which can be an expression or a value, and returns a \emph{field} of the same type (\ref{lst:neighboringViaExchange}).

\begin{lstlisting}[language=kt,label={lst:neighboringViaExchange},caption={The implementation of the \texttt{neighboringViaExchange} function.}]
fun <ID : Any, Scalar> Aggregate<ID>.neighboringViaExchange(local: Scalar): Field<ID, Scalar> =
    exchanging(local) { toYield ->
        toYield.mapToConstantField(local).yielding { toYield }
    }
\end{lstlisting}

As said in \Cref{par:communication-in-xc}, the \texttt{nbr} construct is a peculiar case of \texttt{exchange}, in which
the value of the expression evaluated is sent to neighbours and the values received from them are returned as a field.
In this way, it provides a view of the values computed by the neighbours.
Thus, its implementation consists of a call to the \texttt{exchanging} function, made in such a way as to send the value
evaluated to the neighbours and return the values received from them as a field.

\section{Alchemist Incarnation}
\label{sec:incarnation}
%how, why
%gradle task
%explain what is the alchemist incarnation
An ``incarnation'' serves as the interpreter enabling the \emph{Alchemist Simulator} to comprehend and accurately execute a language.
Specifically designed for \emph{Collektive}, this incarnation employs reflections to locate the aggregate entry point and dictates
the methodology for each iteration of the aggregate program.

As others Alchemist incarnations like \texttt{alchemist-incarnation-scafi} and \\ \texttt{alchemist-incarnation-protelis},
it has been implemented in order to launch the simulations through gradle tasks.

%todo add structure image of the incarnation

\paragraph{CollektiveDevice}
The \emph{CollektiveDevice} is a representation of the device in the \emph{Alchemist Simulator}.
It has the purpose of managing specific sensors and actuators, and has the effective implementation of the network from the
device's perspective, in order to manage its messages to send and the messages received from the neighbours.

A device must have the \emph{environment} in which it is located, the \emph{node} property to be represented in the environment,
a specific \emph{ID} that is the same of the node, a \emph{retention time} for messages which can be null if is necessary
to keep all messages.
It must extend the eventual sensors and the network to manage the communication with the neighbours.

To keep track of the time when the messages arrived and thus to be able to discard them after a certain time,
a private data class \texttt{TimedMessage} has been created that associates the time when each message arrived with the message itself.
In this way, in the effective implementation of the \texttt{read} function of the network, it is possible
to discard the messages that arrived before a certain time, and thus are no longer valid.

\begin{lstlisting}[language=kt,label={lst:read},caption={The implementation of the \texttt{read} function of the \texttt{Network}.}]
override fun read(): Set<InboundMessage<Int>> =
    when (retainMessagesFor) {
        null -> validMessages.mapTo(mutableSetOf()) { it.payload }.also { validMessages.clear() }
        else -> {
            validMessages.retainAll { it.receivedAt + retainMessagesFor >= currentTime }
            validMessages.mapTo(mutableSetOf()) { it.payload }
        }
    }
\end{lstlisting}

In the \Cref{lst:read} snippet is shown how the \texttt{read} function of the network is implemented.
It checks if the \emph{retainMessagesFor} property is null, meaning that it is necessary to keep all the messages,
and in this case it returns the valid messages and clears the set, otherwise it retains only the messages that arrived
after a certain time and returns them converted to a set of \emph{InboundMessage}.

The \texttt{write} function is a bit more complex, having to manage the messages taken as input from the \emph{aggregate context}.
It gets the neighbours of the device, and for each of them it creates an \texttt{InboundMessage} that the neighbour will read.
Due to the structure of the messages, the complicated part has been the managing ot the overrides from the \emph{OutboundMessage}:
not all messages may have an override with messages for specific recipients, so it first checks if the \texttt{ovverrides} are empty,
if so the new message will be populated with the default value, otherwise it will be populated with the value associated with the recipient.

If present, the sensors and actuators are implemented inside the \emph{CollektiveDevice} class.
For example, in this implementation, the \emph{CollektiveDevice} has a \emph{DistanceSensor} that is used to measure the distance
between the device and the neighbours.
The \emph{DistanceSensor}'s method is implemented as an aggregate extension function, and it is used to measure the distance
between the device and the neighbours using the \texttt{neighboringViaExchange} construct, obtaining other devices' positions
and calculating the distance between them, as seen in the code snippet \ref{lst:distance}.
This function can be used in others aggregate programs by simply using the interface \texttt{DistanceSensor} as context receiver.

\begin{lstlisting}[language=kt,label={lst:distance},caption={The implementation of the \texttt{distance} function.}]
override fun <ID : Any> Aggregate<ID>.distances(): Field<ID, Double> =
    environment.getPosition(node).let { nodePosition ->
        neighboringViaExchange(nodePosition).map { position -> nodePosition.distanceTo(position) }
    }
\end{lstlisting}

\paragraph{RunCollektiveProgram}
The \emph{RunCollektiveProgram} is an action for the \emph{Alchemist Simulator} that runs a \emph{Collektive} program.
It takes the \emph{node} on which executes the action, the time distribution of the events and the \emph{additional parameters}
which is the path where the aggregate program to execute is located.

To create an instance of the aggregate program, it has been necessary to use a mechanism called \emph{reflection}.
Reflection is a powerful feature of Kotlin that allows developers to inspect and manipulate the structure of a program at runtime.
It provides a way to access and modify the properties, methods, and types of a program, and to invoke functions and constructors dynamically.
The reflection mechanism permits to obtain the contexts passed to the aggregate program.
It has been necessary also to implement a private cache to store the associated parameters of the aggregate program, in order to
avoid the reflection mechanism every time the program is executed, which is very expensive in terms of performance.

Once it has been created the \emph{Collektive} instance, it is possible to execute the aggregate program running the \texttt{cycle}
or the \texttt{cycleWhile} function.

\paragraph{CollektiveIncarnation}
The \emph{Collektive Incarnation} is the interpreter that enables the \emph{Alchemist Simulator} to understand and execute
the aggregate program written in the \ac{dsl}.

\subsection{Using reflection}
\label{subsec:using-reflection}
