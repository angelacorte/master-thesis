%! Author = angela
%! Date = 24/01/24
% !TeX root = ../thesis-main.tex

\chapter{Validation}
\label{ch:validation}
Validating the hypotheses is a fundamental step for the correct evaluation of the work done.
By comparing the performance of the new implementation with the original one, it is possible to understand if the
introduction of the new features has led to an improvement in the performance of the system.
\section{Tests}
\label{sec:tests}
The testing phase is instrumental in affirming the integrity and functionality of the \ac{dsl} codebase developed for this thesis.
Tests serve as a critical mechanism for verifying the behaviour of the DSL across various scenarios, detecting potential bugs,
and validating adherence to specifications.

Since the \ac{dsl} is designed to be multiplatform, tests are written to ensure that the codebase is compatible with
different platforms, and the results across platforms must be consistent.

To achieve this, Kotlin offers \emph{Multiplatform Extensions}, which allows the testing of the same codebase across
different platforms, such as \emph{JVM}, \emph{JS}, and \emph{Native}, just by adding needed extensions in the \texttt{build.gradle} file.
%sono i seguenti
The targets chosen for the testing are the following:
\begin{itemize}
    \item Linux x64 and ARM64;
    \item Windows x64(MinGW);
    \item MacOS x64 and ARM64;
    \item IOS x64 and (simulator) ARM64;
    \item WatchOS x64 and (simulator) ARM64;
    \item TvOS x64 and (simulator) ARM64;
\end{itemize}

Those were chosen to cover the most common platforms and to ensure that the \ac{dsl} is compatible with the most common
devices, such as smartphones, tablets, and wearables.

The tests are divided into two categories:
\begin{itemize}
    \item \textbf{Unit Tests}: these tests are written to verify the correctness of the codebase at the smallest level.
        They are written to test the behaviour of the functions and classes in isolation.
    \item \textbf{Integration Tests}: these tests are written to verify the correctness of the codebase at the highest level.
        They are written to test the behaviour of the codebase as a whole, and to verify that the different parts of the
        codebase work together as expected.
\end{itemize}
%i test sono stati eseguiti anche tramite l'uso delle github actions quindi su macchine virutali diverse quali
%windows 2022, linux ubuntu 22.04 e macos 12
The tests were run through the use of \emph{GitHub Actions}, which allowed the execution of the tests on different virtual
machines, such as Windows 2022, Linux Ubuntu 22.04, and MacOS 12, and locally on a machine with the following specifications:
\begin{itemize}
    \item \textbf{Processor}: Apple M1;
    \item \textbf{RAM}: 16GB of unified memory;
    \item \textbf{OS}: MacOS Ventura 13.6;
\end{itemize}

\section{Alchemist Simulations}
\label{sec:alchemist-simulations}


%examples
\section{Performance / Comparison}
\label{sec:performance-/-comparison}
To have a clear understanding of the performances of the new implementation, it is necessary to compare it with the other
\emph{ScaFi} and \emph{Protelis}' incarnations.
The comparison is made by running the same simulations on each incarnation and comparing the results.
The simulations are run on the same machine to ensure that the comparison is fair and that the differences are due to the
implementation and not to the hardware.

The performance of the new language has been evaluated through the implementation of 5 types of tests:
\begin{enumerate}
    \item Simple \textbf{state change} of the device, to represent the variation over time of the field;
    \item A \textbf{counter of the neighbours}, to represent the variation of the space;
    \item A \textbf{gradient}, which is a particular case of space-time variation, in which the value of a node is a
        function of the distance from a node considered as a source;
    \item A \textbf{channel with obstacles}, to represent the presence of obstacles in space that influence the communication between nodes;
    \item Simple \textbf{branching} operations, as it has been noticed that branching could be one of the most expensive operations in terms of execution time.
\end{enumerate}

Each test has been run with the same parameters in the three different incarnations with three different simulated times
inside the \emph{Alchemist} simulator, and the results have been analysed and will be further discussed in this section.

\paragraph{Machine Specifications}
The results that will be presented have been obtained by running the simulations on a machine with the following specifications:
\begin{itemize}
    \item \textbf{Processor}: Intel(R) Core(TM) i9-14900KF;
    \item \textbf{RAM}: 64GB 4800mhz;
    \item \textbf{OS}: Linux Manjaro;
\end{itemize}

Other runs have been made on a different machine to ensure that the results are consistent across different hardware,
the machine used is the same as the tests one.

\paragraph{Foreword}
During the evolution of this thesis, it has been noticed that the current implementation of the alignment in \emph{Collektive}
may not be the optimal, as explained in \ref{sec:alignment}, and therefore the results could be influenced by this.
A way to implement a faster check on the alignment has been found, and it will be implemented in the future to have a more accurate comparison.

\paragraph{Field Evolution}
The first test has been implemented using the \texttt{repeat} construct.
It doesn't need any particular setup, as it is a simple state change of the device.

From the results, it is possible to see that the \emph{Protelis} implementation is faster than the \emph{Collektive} one,
which in turn is faster than the \emph{ScaFi} implementation.
%todo

\paragraph{Neighbour Counter}

\paragraph{Gradient}

\paragraph{Channel with Obstacles}

\paragraph{Branching}

\section{Discussion}

